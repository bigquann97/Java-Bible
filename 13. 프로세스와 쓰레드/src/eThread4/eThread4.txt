9.4 volatile
멀티코어 프로세서에는 코어마다 별도의 캐시 존재
코어는 메모리에서 읽어온 값을 캐시에 저장하고, 캐시에서 값을 읽어서 작업 - 다시 같은 값을 읽어올때는 캐시에 있는지 먼저 확인, 없을때만 메모리에서 읽어옴
메모리에 저장된 변수 값 변경되어도, 캐시에 저장된 값 갱신X - 메모리에 저장된 값이 다른경우
=> stopped값 바뀌어도 쓰레드 멈추지 않고 계속 실행

volatile - 코어가 변수의 값을 읽을때 캐시가 아닌 메모리에서 읽어들임
synchronized - 캐시와 메모리간의 동기화가 이루어져 값의 불일치 해소

*volatile로 long과 double을 원자화
JVM - 데이터를 4 byte 단위 처리 - int, int보다 작은 타입 하나의 명령어로 읽거나 쓰기 가능
하지만 데이터 크기 넘어가면, 하나의 명령어로 값 쓸수 없어 변수 값 읽을때 다른 쓰레드 끼어들 수 있음
=> 상수는 변하지 않는 값 - 멀티쓰레드에 안전 - volatile 안붙여도 되고, 못붙임

volatile - 해당 변수 일기 쓰기 원자화 - 작업 나눌 수 없게함 (synchronized)

9.5 fork & join 프레임웍
하나의 작업을 작은 단위로 나눠 여러 쓰레드가 동시에 처리하는 것을 쉽게 만들어줌 - 클래스 상속받아 구현해야함
RecursiveAction - 반환값이 없는 작업을 구현할 때 사용
RecursiveTask - 반환값이 있는 작업을 구현할 때 사용
=> compute() 추상메서드 구현
compute 구현후, 쓰레드풀과 수행할 작업 작성, invoke()로 작업 시작 (start() 호출 처럼)

* compute()의 구현
수행할 작업 외에도, 작업을 어떻게 나눌건지 알려줘야함

* 다른쓰레드의 작업 훔쳐오기
work stealing - 쓰레드풀에 의해 자동으로 이루어짐 - 여러 쓰레드가 골고루 작업을 나누어 처리학 됨

* fork()와 join()
fork - 작업을 쓰레드의 작업 큐에 넣는 것, 작업 큐에 들어간 작업은 더이상 나눌 수 없을 때 까지 나뉨
compute()로 나누고, fork()로 작업 큐에 넣는 작업이 계속해서 반복 - 나눠진 작업 각 쓰레드가 골고루 나눠 처리, 작업 결과는 join()으로 얻음
fork - 비동기메서드(asynchronous method) - 해당 작업을 쓰레드 풀의 작업 큐에 넣는다
join - 동기 메서드(synchronous method) - 해당 작업의 수행이 끝날때까지 기다렸다가, 수행이 끝나면 결과를 반환한다
=> ForkJoinEx1.java