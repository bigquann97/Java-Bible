4. 기본형(primitive type)
4.1 논리형 - boolean
ture or false - 기본값은 false - 0은 false 그 외 true

4.2 문자형 - char
단 하나의 문자만 저장가능 - 문자가 아닌 '문자의 유니코드(정수)'가 저장 됨
컴퓨터는 숫자밖에 모르기 때문에, 모든 데이터를 숫자로 변환하여 저장하는 것
문자 'A' 의 유니코드는 65 => 65를 저장하든 'A'를 저장하든 동일한 결과
char형 변수에 저장된 값을 정수형(int)로 변환 가능
=> CharToCode

특수 문자 다루기
탈출문자 \ 를 통해 표현
\t - tab // \b - backspace // \f - form feed // \n - new line // \r - carriage return
\\ - 역슬래시 // \' - 작은따옴표 // \" - 큰따옴표 // \u유니코드 (예: char a = '\u0041') - 유니코드(16진수) 문자
=> SpecialCharEx

char 타입의 표현 형식
char은 2바이트 - 16자리의 2진수로 표현 - 정수의 개수는 65536개(2의 16승)
음수 표현 필요 X - 0 ~ 65535의 범위를 가짐 => 저장된 숫자에 해당하는 유니코드 문자 출력

인코딩과 디코딩(encoding & decoding)
문자 to 숫자 - 인코딩 // 숫자 to 문자 - 디코딩

아스키(ASCII)
American Standard Code for Information Interchange - 미국 표준 코드 - 128개(2의 7승)문자집합 7bit부호
0~9 , A~Z, a~z가 연속적으로 배치

확장 아스키(Extended ASCII)와 한글
아스키에서 1bit가 남음 - 255개의 문자개수 표현
한글 표현하긴 부족 - 조합형(초성, 중성, 종성 조합) or 완성형(확장 아스키 일부 영역에 해당하는 두 문자코드 조합하여 한글 표현)
확장 완성형(CP 949)가 주로 사용됨 - 한글 윈도우에서 사용하는 문자 인코딩

코드 페이지(code page, cp)
PC사용 지역에 따른 확장아스키 필요 - code page - CP xxx 같은 이름을 가짐 - 한글윈도우는 CP 949, 영어 윈도우는 CP 437

유니코드
서로 다른 문자를 인코딩하며 정보교환 - 전세꼐 모든 문자를 하나의 통일된 문자집합으로 표현 - 유니코드
2byte에서 21bit까지 확장됨 - 새로 추가된 보충문자들은 int타입을 사용해야함
유니코드 문자셋에 번호를 붙인 것이 유니코드 인코딩 - 유니코드 인코딩엔 UTF-8, UTF-16, UTF-32 등 있지만, 자바는 UTF-16 사용
UTF-16은 모든 문자를 2byte 고정크기, UTF-8은 하나의 문자를 1~4byte의 가변크기
두 인코딩 모두 처음 128문자가 아스키와 동일(아스키 그대로 포함)
UTF-16 이 문자 다루기 편하지만, 1byte로 표현 가능한걸 2byte로 표현해 크기 커짐
UTF-8 은 문서의 크기가 작아지지만 문자의 크기가 가변적이라 다루기 어려움 - 문서 크기 작아야 유리해 최근 UTF-8 인코딩으로 작성된 웹문서 늘어남

4.3 정수형 - byte short int long
정수형의 표현형식과 범위
부호비트 + (n-1)bit (타입의크기)
n비트로 표현할 수 있는 정수의 개수 = 2의 n승개 // n비트로 표현 가능한 부호있는 정수의 범위 = -(2의 n-1승) ~ 2의 n-1승 - 1

정수형의 선택 기준
int를 주로 사용 - JVM의 피연산자 스택이 피연산자를 4byte단위로 저장하기 때문
약 20억을 넘어가면 long 사용 - byte, short는 저장공간 중요할 때 사용

정수형의 오버플로우
타입이 표현할 수 있는 값의 범위를 넘어서는 오버플로우
최대값 + 1 = 최소값 // 최소값 - 1 = 최대값

부호있는 정수의 오버플로우
부호비트가 0에서 1이 될때 오버플로우가 발생
최대값 최소값의 관계는 위와 같음
=> OverflowEx

4.4 실수형 - float, double
실수형의 범위와 정밀도
float 정밀도 7자리 , double 정밀도 15자리
=> 얼마나 0에 가깝게 표현할 수 있는가도 중요
실수형은 오버플로우 발생하면 무한대 // 언더플로우(실수형으로 표현 불가한 아주 작은값 - 0이 됨)
정수형과 저장하는 방식이 다름 - 정수(부호와 값) , 실수(부호S, 지수E, 가수M)
즉, 2의 제곱을 곱한형태로 저장해 큰 범위의 값을 저장할 수 있음 - 오차가 발생할 수 있다는 단점
=> FloatEx1

실수형의 저장 방식 - 실수형은 값을 부동소수점수(floating-point)형태로 저장
float S1 , E8, M23 // double S1, E11, M52
부호 Sign, 지수 Exponent, 가수 Mantissa
=> FloatToBinEx
